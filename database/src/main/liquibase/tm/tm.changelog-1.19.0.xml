<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">


  <changeSet id="tm-1.19.0" author="jthebault">
    <comment>Update TM database version number</comment>
    <update tableName="CORE_CONFIG">
      <column name="VALUE" value="1.19.0"/>
      <where>STR_KEY = 'squashtest.tm.database.version'</where>
    </update>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-1" author="aguilhem">
    <comment>Creates sub-tables for Dataset and Parameter</comment>

    <addColumn tableName="DATASET">
      <column name="DATASET_TYPE" type="VARCHAR(255)" defaultValue="TC"/>
    </addColumn>

    <!--TEST_CASE_DATASET junction table-->

    <createTable tableName="TEST_CASE_DATASET">
      <column name="TEST_CASE_ID" type="BIGINT" remarks="fk to table TEST_CASE">
        <constraints nullable="false" references="TEST_CASE(TCLN_ID)"
                     foreignKeyName="fk_test_case_test_case_dataset_local"/>
      </column>
      <column name="DATASET_ID" type="BIGINT" remarks="fk to table DATASET">
        <constraints nullable="false" references="DATASET(DATASET_ID)" foreignKeyName="fk_dataset_test_case_dataset"/>
      </column>
      <column name="DATASET_ORDER" type="int"
              remarks="order of this dataset inside tc datasets">
        <constraints nullable="false"/>
      </column>

    </createTable>



    <addColumn tableName="PARAMETER">
      <column name="PARAM_TYPE" type="VARCHAR(255)" defaultValue="LOCAL"/>
    </addColumn>

    <!--TEST_CASE_PARAMETER junction table-->

    <createTable tableName="TEST_CASE_PARAMETER">
      <column name="TEST_CASE_ID" type="BIGINT" remarks="fk to table TEST_CASE">
        <constraints nullable="false" references="TEST_CASE(TCLN_ID)"
                     foreignKeyName="fk_test_case_test_case_parameter_entity_bound"/>
      </column>
      <column name="PARAM_ID" type="BIGINT" remarks="fk to table PARAMETER">
        <constraints nullable="false" references="PARAMETER(PARAM_ID)"
                     foreignKeyName="fk_parameter_test_case_parameter"/>
      </column>
      <column name="PARAM_ORDER" type="int"
              remarks="order of this parameter inside tc datasets">
        <constraints nullable="false"/>
      </column>
    </createTable>



    <!--DATASET_PARAMETER junction table-->

    <createTable tableName="DATASET_PARAMETER">
      <column name="PARAM_ID" type="BIGINT" remarks="fk to table PARAMETER">
        <constraints nullable="false" references="PARAMETER(PARAM_ID)" foreignKeyName="fk_parameter_dataset_parameter"/>
      </column>
      <column name="DATASET_ID" type="BIGINT" remarks="fk to table DATASET">
        <constraints nullable="false" references="DATASET(DATASET_ID)" foreignKeyName="fk_dataset_dataset_parameter"/>
      </column>
      <column name="PARAM_ORDER" type="int"
              remarks="order of this parameter inside global dataset parameters">
        <constraints nullable="false"/>
      </column>
    </createTable>



    <!--DATASET relationship-->

    <createTable tableName="DATASET_RELATIONSHIP">
      <column name="ANCESTOR_ID" type="BIGINT" remarks="fk to parent node">
        <constraints nullable="false" references="DATASET(DATASET_ID)"
                     foreignKeyName="fk_dataset_relationship_ancestor"/>
      </column>
      <column name="DESCENDANT_ID" type="BIGINT" remarks="fk to child node">
        <constraints nullable="false" references="DATASET(DATASET_ID)"
                     foreignKeyName="fk_dataset_relationship_descendant"/>
      </column>
      <column name="CONTENT_ORDER" type="BIGINT" remarks="order in parent content"/>
    </createTable>

    <createTable tableName="DATASET_RELATIONSHIP_CLOSURE">
      <column name="ANCESTOR_ID" type="BIGINT"
              remarks="fk to parent node. Can be fk to itself with a 0 depht">
        <constraints nullable="false" references="DATASET(DATASET_ID)"
                     foreignKeyName="fk_dataset_relationship_closure_ancestor"/>
      </column>
      <column name="DESCENDANT_ID" type="BIGINT"
              remarks="fk to child node. Can be fk to itself with a 0 depht">
        <constraints nullable="false" references="DATASET(DATASET_ID)"
                     foreignKeyName="fk_dataset_relationship_closure_descendant"/>
      </column>
      <column name="DEPTH" type="SMALLINT"
              remarks="stores how deep is the descendant element nested in the subtree of the ancestor element">
        <constraints nullable="false"/>
      </column>
    </createTable>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-2" author="jthebault">
    <comment>Changeset for data migration : The test case referenced by a dataset is not a simple fk anymore</comment>
    <sql>
      insert into TEST_CASE_DATASET(TEST_CASE_ID,DATASET_ID,DATASET_ORDER)
       select TEST_CASE_ID,DATASET_ID, 0 from DATASET
       order by TEST_CASE_ID,DATASET_ID;
    </sql>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-3-h2" author="jthebault" dbms="h2">
  <sql>
    update TEST_CASE_DATASET TCD
    set DATASET_ORDER = (SELECT SUB_QUERY.ORDER_DEF
    from(
      select  DS1.TEST_CASE_ID as TC_ID,
              DS1.DATASET_ID as DS_ID,
              count (*) -1 as ORDER_DEF
      from TEST_CASE_DATASET DS1
        inner join TEST_CASE_DATASET DS2
          on DS1.TEST_CASE_ID = DS2.TEST_CASE_ID and DS1.DATASET_ID >= DS2.DATASET_ID
      group by DS1.TEST_CASE_ID, DS1.DATASET_ID
      ) as SUB_QUERY
    where SUB_QUERY.TC_ID = TCD.TEST_CASE_ID and SUB_QUERY.DS_ID=TCD.DATASET_ID);
  </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-3-mysql" author="jthebault" dbms="mysql">
    <sql>
      update TEST_CASE_DATASET AS TCD
        inner JOIN (
          select
            DS1.TEST_CASE_ID as TC_ID,
            DS1.DATASET_ID   as DS_ID,
            (count(*) - 1)   as ORDER_DEF
          from TEST_CASE_DATASET DS1
            inner join TEST_CASE_DATASET DS2
              on DS1.TEST_CASE_ID = DS2.TEST_CASE_ID and DS1.DATASET_ID >= DS2.DATASET_ID
          group by DS1.TEST_CASE_ID, DS1.DATASET_ID
        ) as SUB_QUERY on SUB_QUERY.TC_ID = TCD.TEST_CASE_ID and SUB_QUERY.DS_ID = TCD.DATASET_ID
      set TCD.DATASET_ORDER = SUB_QUERY.ORDER_DEF;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-3-postgresql" author="jthebault" dbms="postgresql">
    <sql>
      update TEST_CASE_DATASET TCD
      set DATASET_ORDER = SUB_QUERY.ORDER_DEF
      from(
        select  DS1.TEST_CASE_ID as TC_ID,
                DS1.DATASET_ID as DS_ID,
                count (*) -1 as ORDER_DEF
        from TEST_CASE_DATASET DS1
          inner join TEST_CASE_DATASET DS2
            on DS1.TEST_CASE_ID = DS2.TEST_CASE_ID and DS1.DATASET_ID >= DS2.DATASET_ID
        group by DS1.TEST_CASE_ID, DS1.DATASET_ID
      ) as SUB_QUERY
      where SUB_QUERY.TC_ID = TCD.TEST_CASE_ID and SUB_QUERY.DS_ID=TCD.DATASET_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-4" author="jthebault">
    <comment>Changeset for data migration : The test case referenced by a paramter is not a simple fk anymore</comment>
    <sql>
      insert into TEST_CASE_PARAMETER(TEST_CASE_ID,PARAM_ID,PARAM_ORDER)
      select TEST_CASE_ID,PARAM_ID, 0 from PARAMETER
      order by TEST_CASE_ID,PARAM_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-5-h2" author="jthebault" dbms="h2">
    <sql>
      update TEST_CASE_PARAMETER TCP
      set PARAM_ORDER = (SELECT SUB_QUERY.ORDER_DEF
      from(
        select  TP1.TEST_CASE_ID as TC_ID,
                TP1.PARAM_ID as PR_ID,
                count (*) -1 as ORDER_DEF
        from TEST_CASE_PARAMETER TP1
          inner join TEST_CASE_PARAMETER TP2
            on TP1.TEST_CASE_ID = TP2.TEST_CASE_ID and TP1.PARAM_ID >= TP2.PARAM_ID
        group by TP1.TEST_CASE_ID, TP1.PARAM_ID
        ) as SUB_QUERY
      where SUB_QUERY.TC_ID = TCP.TEST_CASE_ID and SUB_QUERY.PR_ID=TCP.PARAM_ID);
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-5-mysql" author="jthebault" dbms="mysql">
    <sql>
      update TEST_CASE_PARAMETER AS TCP
      inner JOIN (
        select
          TP1.TEST_CASE_ID as TC_ID,
          TP1.PARAM_ID   as PR_ID,
          (count(*) - 1)   as ORDER_DEF
        from TEST_CASE_PARAMETER TP1
          inner join TEST_CASE_PARAMETER TP2
            on TP1.TEST_CASE_ID = TP2.TEST_CASE_ID and TP1.PARAM_ID >= TP2.PARAM_ID
        group by TP1.TEST_CASE_ID, TP1.PARAM_ID
        ) as SUB_QUERY on SUB_QUERY.TC_ID = TCP.TEST_CASE_ID and SUB_QUERY.PR_ID = TCP.PARAM_ID
      set TCP.PARAM_ORDER = SUB_QUERY.ORDER_DEF;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-5-postgresql" author="jthebault" dbms="postgresql">
    <sql>
      update TEST_CASE_PARAMETER TCP
      set PARAM_ORDER = SUB_QUERY.ORDER_DEF
      from(
        select  TP1.TEST_CASE_ID as TC_ID,
                TP1.PARAM_ID as PR_ID,
                count (*) -1 as ORDER_DEF
        from TEST_CASE_PARAMETER TP1
          inner join TEST_CASE_PARAMETER TP2
            on TP1.TEST_CASE_ID = TP2.TEST_CASE_ID and TP1.PARAM_ID >= TP2.PARAM_ID
        group by TP1.TEST_CASE_ID, TP1.PARAM_ID
        ) as SUB_QUERY
      where SUB_QUERY.TC_ID = TCP.TEST_CASE_ID and SUB_QUERY.PR_ID=TCP.PARAM_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-6" author="jthebault" dbms="h2">
    <addUniqueConstraint tableName="TEST_CASE_PARAMETER" columnNames="TEST_CASE_ID, PARAM_ORDER"
                          constraintName="uc_test_case_param_order"/>

    <addUniqueConstraint tableName="TEST_CASE_DATASET" columnNames="TEST_CASE_ID, DATASET_ORDER"
                          constraintName="uc_test_case_dataset_order"/>

    <addUniqueConstraint tableName="DATASET_PARAMETER" columnNames="DATASET_ID, PARAM_ORDER"
                          constraintName="uc_dataset_param_order"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-7-h2" author="jthebault" dbms="h2">
    <dropUniqueConstraint tableName="PARAMETER" constraintName="CONSTRAINT_1A96" uniqueColumns="NAME,TEST_CASE_ID"/>
    <dropForeignKeyConstraint baseTableName="PARAMETER" constraintName="FK_PARAMETER_TEST_CASE"/>
    <dropColumn tableName="PARAMETER" columnName="TEST_CASE_ID"/>

    <dropUniqueConstraint tableName="DATASET" constraintName="CONSTRAINT_80D"/>
    <dropForeignKeyConstraint baseTableName="DATASET" constraintName="FK_DATASET_TEST_CASE"/>
    <dropColumn tableName="DATASET" columnName="TEST_CASE_ID"/>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-7-mysql" author="jthebault" dbms="mysql">
    <dropUniqueConstraint tableName="PARAMETER" constraintName="NAME" uniqueColumns="NAME,TEST_CASE_ID"/>
    <dropForeignKeyConstraint baseTableName="PARAMETER" constraintName="fk_parameter_test_case"/>
    <dropColumn tableName="PARAMETER" columnName="TEST_CASE_ID"/>

    <dropUniqueConstraint tableName="DATASET" constraintName="NAME" uniqueColumns="NAME,TEST_CASE_ID"/>
    <dropForeignKeyConstraint baseTableName="DATASET" constraintName="fk_dataset_test_case"/>
    <dropColumn tableName="DATASET" columnName="TEST_CASE_ID"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-7-postgresql" author="jthebault" dbms="postgresql">
    <dropUniqueConstraint tableName="PARAMETER" constraintName="parameter_name_test_case_id_key" uniqueColumns="NAME,TEST_CASE_ID"/>
    <dropForeignKeyConstraint baseTableName="PARAMETER" constraintName="FK_PARAMETER_TEST_CASE"/>
    <dropColumn tableName="PARAMETER" columnName="TEST_CASE_ID"/>

    <dropUniqueConstraint tableName="DATASET" constraintName="dataset_name_test_case_id_key" uniqueColumns="NAME,TEST_CASE_ID"/>
    <dropForeignKeyConstraint baseTableName="DATASET" constraintName="fk_dataset_test_case"/>
    <dropColumn tableName="DATASET" columnName="TEST_CASE_ID"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-8" author="aguilhem">
    <comment>Create sub-tables for Dataset Tree</comment>

    <!-- DATASET_LIBRARY TABLE -->

    <createTable tableName="DATASET_LIBRARY">
      <column name="DL_ID" type="BIGINT" autoIncrement="true" remarks="pk genere">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_DATASET_LIBRARY"/>
      </column>

      <column name="ATTACHMENT_LIST_ID" type="BIGINT" remarks="FK to ATTACHMENT_LIST">
      </column>
    </createTable>

    <createIndex tableName="DATASET_LIBRARY" indexName="IDX_DATASET_LIBRARY">
      <column name="DL_ID"/>
    </createIndex>

    <addForeignKeyConstraint constraintName="fk_dl_attachment_list" baseTableName="DATASET_LIBRARY"
                             baseColumnNames="ATTACHMENT_LIST_ID" referencedTableName="ATTACHMENT_LIST" referencedColumnNames="ATTACHMENT_LIST_ID" />

    <addColumn tableName="PROJECT">
      <column name="DL_ID" type="BIGINT" remarks="FK for DATASET_LIBRARY.DL_ID"/>
    </addColumn>

    <addForeignKeyConstraint constraintName="fk_project_dl" baseTableName="PROJECT"
                             baseColumnNames="DL_ID" referencedTableName="DATASET_LIBRARY" referencedColumnNames="DL_ID" />

    <!--DATASET_LIBRARY_NODE_TABLE-->

    <createTable tableName="DATASET_LIBRARY_NODE">
      <column name="DLN_ID" type="BIGINT" autoIncrement="true" remarks="pk genere">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_DATASET_LIBRARY_NODE"/>
      </column>

      <column name="NAME" type="VARCHAR(255)"/>

      <column name="ENTITY_TYPE" type="VARCHAR(50)"/>

      <column name="ENTITY_ID" type="BIGINT"/>

      <column name="DL_ID" type="BIGINT" remarks="fk to the containing DATASET_LIBRARY">
        <constraints nullable="true" foreignKeyName="fk_dln_dataset_library_dl_id" references="DATASET_LIBRARY(DL_ID)"/>
      </column>

    </createTable>

    <createTable tableName="DATASET_FOLDER">
      <column name="DF_ID" type="BIGINT" autoIncrement="true" remarks="generated pk">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_DF_ID"/>
      </column>

      <column name="NAME" type="VARCHAR(255)"/>

      <column name="DESCRIPTION" type="CLOB"/>

      <column name="PROJECT_ID" type="BIGINT" remarks="fk to project">
        <constraints nullable="false" foreignKeyName="fk_project_dataset_folder_project_id"
                     references="PROJECT(PROJECT_ID)"/>
      </column>

    </createTable>


    <!-- DATASET_LIBRARY_NODE Relationship -->

    <comment>This table contains the relations between two datasets nodes. If a node is root, parent id will be null and
      descendant id will be itself.
      a given node can be referenced as descendant only one time so we can map the join with hibernate
    </comment>
    <createTable tableName="DLN_RELATIONSHIP">

      <column name="ANCESTOR_ID" type="BIGINT" remarks="fk to parent node">
        <constraints nullable="true" foreignKeyName="fk_dln_relationship_ancestor"
                     references="DATASET_LIBRARY_NODE(DLN_ID)"/>
      </column>

      <column name="DESCENDANT_ID" type="BIGINT" remarks="fk to child">
        <constraints nullable="false" foreignKeyName="fk_dln_relationship_descendant"
                     references="DATASET_LIBRARY_NODE(DLN_ID)"/>
      </column>

      <column name="CONTENT_ORDER" type="BIGINT" remarks="content order">
      </column>
    </createTable>

    <createIndex tableName="DLN_RELATIONSHIP" indexName="idx_dln_relationship_descendant">
      <column name="DESCENDANT_ID"/>
    </createIndex>

    <createIndex tableName="DLN_RELATIONSHIP" indexName="idx_dln_relationship_ancestor">
      <column name="ANCESTOR_ID"/>
    </createIndex>

    <createTable tableName="DLN_RELATIONSHIP_CLOSURE">
      <column name="ANCESTOR_ID" type="BIGINT"
              remarks="fk to parent node. Can be fk to itself with a 0 depth">
        <constraints nullable="false" references="DATASET_LIBRARY_NODE(DLN_ID)"
                     foreignKeyName="fk_dln_relationship_closure_ancestor"/>
      </column>
      <column name="DESCENDANT_ID" type="BIGINT"
              remarks="fk to child node. Can be fk to itself with a 0 depth">
        <constraints nullable="false" references="DATASET_LIBRARY_NODE(DLN_ID)"
                     foreignKeyName="fk_dln_relationship_closure_descendant"/>
      </column>
      <column name="DEPTH" type="SMALLINT"
              remarks="stores how deep is the descendant element nested in the subtree of the ancestor element">
        <constraints nullable="false"/>
      </column>
    </createTable>

    <createIndex tableName="DLN_RELATIONSHIP_CLOSURE"
                 indexName="idx_dln_relationship_clos_desc">
      <column name="DESCENDANT_ID" />
    </createIndex>

    <createIndex tableName="DLN_RELATIONSHIP_CLOSURE"
                 indexName="idx_dln_relationship_clos_anc">
      <column name="ANCESTOR_ID" />
    </createIndex>

    <addUniqueConstraint tableName="DLN_RELATIONSHIP_CLOSURE" columnNames="ANCESTOR_ID, DESCENDANT_ID"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-9" author="aguilhem">
    <comment>ACL permission on Dataset Library</comment>

    <insert tableName="ACL_CLASS">
      <column name="CLASSNAME" value="org.squashtest.tm.domain.dataset.DatasetLibrary"/>
    </insert>

    <!-- To complete with ACL Permission for each profile -->

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-10" author="aguilhem">
    <comment>Migration for dataset workspace evolution. Creates DatasetLibrary entities, attachment list and their nodes...</comment>

    <!-- Add temporary column for migration purpose -->
    <addColumn tableName="ATTACHMENT_LIST">
      <column name="TMP_DL_ID" type="BIGINT" remarks="TMP FK FOR DATASET_LIBRARY.DL_ID"/>
    </addColumn>

    <!-- SQL CREATE A NEW DATASET_LIBRARY FOR EACH PROJECT IN DB AND CREATE ACLS ON OBJECT-->

    <!-- Note : we force DLN_ID = PROJECT_ID.
    Although not technically needed, this is more aesthetic and convenient.
    -->
    <sql>
      insert into DATASET_LIBRARY (DL_ID)
      select p.PROJECT_ID
      from PROJECT p;

      update PROJECT p
      set DL_ID = PROJECT_ID;

      insert into ACL_OBJECT_IDENTITY (IDENTITY,CLASS_ID)
      select DL_ID, ID from DATASET_LIBRARY,ACL_CLASS
      where ACL_CLASS.CLASSNAME LIKE 'org.squashtest.tm.domain.dataset.DatasetLibrary';
    </sql>



    <!-- SQL CREATE A NEW ATTACHEMENT_LIST FOR EACH PREVIOUSLY DATASET_LIBRARY IN DB -->
    <sql>
      insert into ATTACHMENT_LIST (TMP_DL_ID)
      select DL_ID
      from DATASET_LIBRARY dl;

      update DATASET_LIBRARY dl
      set ATTACHMENT_LIST_ID = (
      select ATTACHMENT_LIST_ID
      from ATTACHMENT_LIST al
      where dl.DL_ID = al.TMP_DL_ID
      );

    </sql>
    <sql>

      insert into DATASET_LIBRARY_NODE (ENTITY_ID,DL_ID,ENTITY_TYPE)
      select DL_ID,DL_ID,'LIBRARY'
      from DATASET_LIBRARY;

    </sql>
    <sql>

      update DATASET_LIBRARY_NODE
      set NAME = (
      select p.NAME
      from PROJECT p
      where ENTITY_ID = p.DL_ID
      )
      where ENTITY_TYPE = 'LIBRARY';

    </sql>


    <!-- REMOVE TMP COLUMNS USED FOR MIGRATION -->
    <dropColumn tableName="ATTACHMENT_LIST" columnName="TMP_DL_ID" />

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-11" author="aguilhem" dbms="postgresql">
    <comment>update the sequences afterward</comment>
    <sql>
      SELECT setval('dataset_library_dl_id_seq', (SELECT MAX(DL_ID) from DATASET_LIBRARY));
      SELECT setval('dataset_library_node_dln_id_seq', (SELECT MAX(DLN_ID) from DATASET_LIBRARY_NODE));
      SELECT setval('acl_object_identity_id_seq', (SELECT MAX(ID) from ACL_OBJECT_IDENTITY));
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-12-postgresql" author="aguilhem"
             dbms="postgresql">
    <comment>postgresql-triggers for DLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a dl node : create auto reference in the closure table -->
    <createProcedure>
      drop trigger if exists ins_dln_after on DATASET_LIBRARY_NODE;
      drop function if exists ins_dln_after();
      create function ins_dln_after() returns trigger as $ins_dln_after$
      begin
      insert into DLN_RELATIONSHIP_CLOSURE
      values (new.dln_id, new.dln_id, 0);
      return new;
      end;
      $ins_dln_after$ language plpgsql;

      create trigger ins_dln_after after insert on DATASET_LIBRARY_NODE
      for each row execute procedure ins_dln_after();

    </createProcedure>



    <!-- before suppression of a dl node : remove auto reference from the closure table -->
    <createProcedure>
      drop trigger if exists del_dln_before on DATASET_LIBRARY_NODE;
      drop function if exists del_dln_before();
      create function del_dln_before() returns trigger as $del_dln_before$
      begin
      delete from DLN_RELATIONSHIP_CLOSURE
      where ancestor_id = old.dln_id
      and descendant_id = old.dln_id;
      return old;
      end;
      $del_dln_before$ language plpgsql;

      create trigger del_dln_before before delete on DATASET_LIBRARY_NODE
      for each row execute procedure del_dln_before();

    </createProcedure>


    <!-- when two dl nodes are attached : attach the subtrees as well. -->
    <createProcedure>
      drop trigger if exists attach_dln_after on DLN_RELATIONSHIP;
      drop function if exists attach_dln_after();
      create function attach_dln_after() returns trigger as $attach_dln_after$
      begin
      insert into DLN_RELATIONSHIP_CLOSURE
      select d1.ancestor_id, d2.descendant_id, d1.depth + d2.depth + 1
      from DLN_RELATIONSHIP_CLOSURE d1
      cross join DLN_RELATIONSHIP_CLOSURE d2
      where d1.descendant_id = new.ancestor_id
      and d2.ancestor_id = new.descendant_id;
      return new;
      end;
      $attach_dln_after$ language plpgsql;

      create trigger attach_dln_after after insert on DLN_RELATIONSHIP
      for each row execute procedure attach_dln_after();

    </createProcedure>


    <!-- when two dl nodes are detached : detach the subtrees as well -->
    <createProcedure>
      drop trigger if exists detach_dln_before on DLN_RELATIONSHIP;
      drop function if exists detach_dln_before();
      create function detach_dln_before() returns trigger as $detach_dln_before$
      begin
      delete from DLN_RELATIONSHIP_CLOSURE
      where descendant_id in ( select descendant_id from DLN_RELATIONSHIP_CLOSURE where ancestor_id = old.descendant_id )
      and ancestor_id not in ( select descendant_id from DLN_RELATIONSHIP_CLOSURE where ancestor_id = old.descendant_id )
      ;
      return old;
      end;
      $detach_dln_before$ language plpgsql;

      create trigger detach_dln_before before delete on DLN_RELATIONSHIP
      for each row execute procedure detach_dln_before();

    </createProcedure>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-194-12-h2" author="aguilhem" dbms="h2">

    <comment>h2-triggers for DLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a dl node : create auto reference in the closure
          table -->
    <sql>
      create trigger ins_dln_after after insert on
      DATASET_LIBRARY_NODE
      for each row call
      "org.squashtest.csp.h2.triggers.DLNAfterInsert";
    </sql>



    <!-- before suppression of a cl node : remove auto reference from the closure
          table -->
    <sql>
      create trigger del_dln_before before delete on
      DATASET_LIBRARY_NODE
      for each row call
      "org.squashtest.csp.h2.triggers.DLNBeforeDelete";
    </sql>


    <!-- when two cl nodes are attached : attach the subtrees as well. -->
    <sql>
      create trigger attach_dln_after after insert on DLN_RELATIONSHIP
      for each row call "org.squashtest.csp.h2.triggers.DLNAfterAttach";
    </sql>


    <!-- when two cl nodes are detached : detach the subtrees as well -->
    <sql>
      create trigger detach_dln_before before delete on
      DLN_RELATIONSHIP
      for each row call
      "org.squashtest.csp.h2.triggers.DLNBeforeDetach";
    </sql>

  </changeSet>

  <!-- ************** /h2 triggers **************** -->

  <changeSet id="tm-1.19.0-SQTM-194-12-mysql" author="aguilhem"
             dbms="mysql">
    <comment>mysql-triggers for DLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a dl node : create auto reference in the closure
          table -->
    <sql>
      create trigger ins_dln_after after insert on
      DATASET_LIBRARY_NODE
      for each row insert ignore into
      DLN_RELATIONSHIP_CLOSURE values (new.dln_id, new.dln_id, 0);
    </sql>



    <!-- before suppression of a dl node : remove auto reference from the closure
          table -->
    <sql>
      create trigger del_dln_before before delete on
      DATASET_LIBRARY_NODE
      for each row delete from
      DLN_RELATIONSHIP_CLOSURE where ancestor_id=old.dln_id and
      descendant_id=old.dln_id;
    </sql>


    <!-- when two dl nodes are attached : attach the subtrees as well. -->
    <sql>
      create trigger attach_dln_after after insert on DLN_RELATIONSHIP
      for each row insert ignore into DLN_RELATIONSHIP_CLOSURE
      select
      d1.ancestor_id, d2.descendant_id, d1.depth+d2.depth+1
      from
      DLN_RELATIONSHIP_CLOSURE d1
      cross join DLN_RELATIONSHIP_CLOSURE d2
      where d1.descendant_id = new.ancestor_id
      and d2.ancestor_id = new.descendant_id;
    </sql>


    <!-- when two dl nodes are detached : detach the subtrees as well -->
    <sql>
      create trigger detach_dln_before before delete on
      DLN_RELATIONSHIP
      for each row delete clos1 from
      DLN_RELATIONSHIP_CLOSURE clos1
      join DLN_RELATIONSHIP_CLOSURE clos2
      on
      clos1.descendant_id=clos2.descendant_id
      left join
      DLN_RELATIONSHIP_CLOSURE clos3
      on clos3.ancestor_id = clos2.ancestor_id
      and clos3.descendant_id = clos1.ancestor_id
      where
      clos2.ancestor_id = old.descendant_id
      and clos3.ancestor_id is null;
    </sql>
  </changeSet>

</databaseChangeLog>
