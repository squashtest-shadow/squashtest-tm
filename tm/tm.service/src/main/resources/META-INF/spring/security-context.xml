<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) 2010 - 2012 Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd
		http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.xsd">

  <security:global-method-security
    secured-annotations="enabled" pre-post-annotations="enabled"
    access-decision-manager-ref="squashtest.core.security.AclDecisionManager"
    order="2">
    <security:expression-handler ref="expressionHandler" />
  </security:global-method-security>

  <!-- anonymous bean instead ? -->
  <bean class="org.springframework.security.access.vote.AffirmativeBased"
    id="squashtest.core.security.AclDecisionManager">
    <property name="decisionVoters">
      <list>
        <ref bean="preInvocationAuthorizationAdviceVoter" />
      </list>
    </property>
    <property name="allowIfAllAbstainDecisions" value="true" />
  </bean>

  <!-- anonymous bean instead ? -->
  <bean
    class="org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter"
    id="preInvocationAuthorizationAdviceVoter">
    <constructor-arg>
      <ref bean="preInvocationAdvice" />
    </constructor-arg>
  </bean>


  <!-- anonymous bean instead ? -->
  <bean
    class="org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice"
    id="preInvocationAdvice">
    <property name="expressionHandler" ref="expressionHandler" />
  </bean>

  <bean id="expressionHandler"
    class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler">
    <property name="permissionEvaluator" ref="squashtest.core.security.PermissionEvaluator" />
    <property name="parameterNameDiscoverer">
      <!-- We use 2 param name discovery strategies : the standard one and a "arg0, arg1" fallback -->
      <bean
        class="org.squashtest.tm.service.internal.spring.CompositeDelegatingParameterNameDiscoverer">
        <constructor-arg>
          <list>
            <bean
              class="org.springframework.core.LocalVariableTableParameterNameDiscoverer" />
            <bean
              class="org.squashtest.tm.service.internal.spring.ArgumentPositionParameterNameDiscoverer" />
          </list>
        </constructor-arg>
      </bean>
    </property>
  </bean>

<!--  vient de core.web -->
  <bean id="squashtest.core.security.JdbcUserDetailsManager" class="org.springframework.security.provisioning.JdbcUserDetailsManager">

    <property name="dataSource" ref="squashtest.core.persistence.jdbc.DataSource" />

    <property name="usersByUsernameQuery" value="select LOGIN, PASSWORD, ACTIVE from AUTH_USER where LOGIN = ?" />

    <property name="groupAuthoritiesByUsernameQuery">
      <value>
        select g.ID, g.QUALIFIED_NAME, ga.AUTHORITY
        from CORE_GROUP g
        inner join CORE_GROUP_AUTHORITY ga on ga.GROUP_ID = g.ID
        inner join CORE_GROUP_MEMBER gm on gm.GROUP_ID = g.ID
        inner join CORE_USER u on u.ID = gm.USER_ID
        where u.LOGIN = ?
      </value>
    </property> 
    
    <!--  dummy query, see explanation below -->
    <property name="authoritiesByUsernameQuery" value="select login, 'ROLE_USER' from CORE_USER where login = ?">

    </property>

    <property name="changePasswordSql">
      <value>
        update AUTH_USER
        set PASSWORD = ?
        where LOGIN = ?
      </value>
    </property>

    <property name="updateUserSql">
      <value>
        update AUTH_USER
        set PASSWORD = ?, ACTIVE = ?
        where LOGIN = ?
      </value>
    </property>

    <property name="deleteUserSql">
      <value>
        delete from AUTH_USER
        where LOGIN = ?
      </value>
    </property>


    <property name="createUserSql">
      <value>
        insert into AUTH_USER (LOGIN, PASSWORD, ACTIVE) values (?,?,?)
      </value>
    </property>
    
    <!--  
      A successful login attempt requires the user to have at least one authority set (and also a valid login/pass).
      
      Our policy regarding authorities is group-based : there are no per-user authorities and they 
      must be attached to a group.
      
      However due to the restriction mentioned above (about successful login),  we want the user to be granted 
      a default authority if he doesn't belong to a group yet. That authority can merely allow him to 
      connect to the application, but without proper entry in acls he couldn't do much anyway.
      
      So we fetch both personal authorities for the default one, and the group authorities for the real ones. 
      
    -->   
    <!-- 
      Why did the property "enableAuthorities" changed from "true" to "false" ?
    
      The property "enableAuthorities" was at "true" because, at the beginning of squash, users were created "by hand" and for a non admin,  
      no entry was put in the table "CORE_GROUP_MEMBER". In this case, if the property were at "false", the user could not access to  
      the squash workspace.  
      
      Now that users are created with squash, an entry in the table CORE_GROUP_MEMBER is guaranteed. The property could have remained at "true" 
      if it was not for the functionality that allows a user to change his login [Issue 806]. To do that, spring would make us delete the old AUTH_USER entry and create a 
      new one. While deleting a user it would try to delete all his authorities, and that we don't want. Therefore, now enableAuthorities is "false". 
      
    -->
    <property name="enableAuthorities" value="false" />
    <property name="enableGroups" value="true" />
  </bean>
  
    <!-- ====== SECURITY PLUMBING ====== -->
  <bean class="org.springframework.security.acls.AclPermissionEvaluator" id="squashtest.core.security.PermissionEvaluator">
    <constructor-arg ref="squashtest.core.security.AclService" />
    <property name="objectIdentityRetrievalStrategy" ref="squashtest.core.security.ObjectIdentityRetrievalStrategy" />
    <property name="objectIdentityGenerator" ref="squashtest.core.security.ObjectIdentityGeneratorStrategy" />
    <property name="permissionFactory" ref="permissionFactory" />
  </bean>

  <bean class="org.squashtest.tm.service.security.acls.jdbc.JdbcManageableAclService" id="squashtest.core.security.AclService" lazy-init="false">
    <constructor-arg ref="squashtest.core.persistence.jdbc.DataSource" />
    <constructor-arg ref="lookupStrategy" />
    <property name="aclCache" ref="aclCache" /> <!-- about that heresy, see comments in JdbcManageableAclService sources -->

    <property name="findChildrenQuery">
      <value>
        select null as obj_id,
        null as class
        from ACL_OBJECT_IDENTITY
        where 0 = 1
      </value>
    </property>
  </bean>

  <bean id="lookupStrategy" class="org.springframework.security.acls.jdbc.BasicLookupStrategy">
    <constructor-arg ref="squashtest.core.persistence.jdbc.DataSource" />
    <constructor-arg ref="aclCache" />
    <constructor-arg>
      <bean class="org.springframework.security.acls.domain.AclAuthorizationStrategyImpl">
        <constructor-arg>
          <list>
            <ref local="aclAdminAuthority" />
            <ref local="aclAdminAuthority" />
            <ref local="aclAdminAuthority" />
          </list>
        </constructor-arg>
      </bean>
    </constructor-arg>
    <constructor-arg>
        <bean class="org.squashtest.tm.service.security.acls.Slf4jAuditLogger" />
    </constructor-arg>
    <property name="permissionFactory" ref="permissionFactory" />
    <property name="selectClause">
      <value>
        select oid.IDENTITY as object_id_identity,
        gp.PERMISSION_ORDER,
        oid.ID as acl_id,
        null as parent_object, /*
        oid.parent */
        true as entries_inheriting, /* oid.entries_inheriting*/
        rse.ID as ace_id,
        gp.PERMISSION_MASK as mask,
        gp.GRANTING as granting,
        true as audit_success, /* audit success */
        false as audit_failure, /* audit failure */
        true as ace_principal, /* sid is principal */
        u.LOGIN as ace_sid,
        true as acl_principal, /* owner is prinipal */
        u.LOGIN as acl_sid, /* owner sid */
        ocl.CLASSNAME as class
        from ACL_OBJECT_IDENTITY oid
        left join ACL_CLASS ocl on
        ocl.ID = oid.CLASS_ID
        left join ACL_GROUP_PERMISSION gp on gp.CLASS_ID = ocl.ID
        left join ACL_GROUP g on g.ID =
        gp.ACL_GROUP_ID
        left join ACL_RESPONSIBILITY_SCOPE_ENTRY rse on rse.ACL_GROUP_ID = g.ID and
        rse.OBJECT_IDENTITY_ID = oid.ID
        inner join CORE_USER u on u.ID = rse.USER_ID
        where (
      </value>
    </property>
    <property name="lookupObjectIdentitiesWhereClause">
      <value>(oid.IDENTITY = ? and ocl.CLASSNAME = ?)</value>
    </property>
    <property name="lookupPrimaryKeysWhereClause">
      <value>(oid.ID = ?)</value>
    </property>
    <property name="orderByClause">
      <value>) order by oid.IDENTITY asc, gp.PERMISSION_ORDER asc</value>
    </property>
  </bean>

  <bean id="aclAdminAuthority" class="org.springframework.security.core.authority.GrantedAuthorityImpl">
    <constructor-arg value="ROLE_ADMIN" />
  </bean>

  <!--  @Component ? -->
  <bean id="permissionFactory" class="org.squashtest.tm.service.security.acls.CustomPermissionFactory" />

  <bean id="aclCache" class="org.springframework.security.acls.domain.EhCacheBasedAclCache" >
    <constructor-arg>
      <bean class="org.springframework.cache.ehcache.EhCacheFactoryBean">
        <property name="cacheManager">
          <bean class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" />
        </property>
        <property name="overflowToDisk" value="false" />
        <property name="timeToIdle" value="600" />
        <property name="timeToLive" value="1800" />
      </bean>
    </constructor-arg>
  </bean>
  
</beans>
