<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) 2010 - 2014 Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd
		http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd">

  <security:global-method-security
    secured-annotations="enabled" pre-post-annotations="enabled"
    access-decision-manager-ref="squashtest.core.security.AclDecisionManager"
    order="2">
    <security:expression-handler ref="expressionHandler" />
  </security:global-method-security>

  <!-- anonymous bean instead ? -->
  <bean class="org.springframework.security.access.vote.AffirmativeBased"
    id="squashtest.core.security.AclDecisionManager">
    <property name="decisionVoters">
      <list>
        <ref bean="preInvocationAuthorizationAdviceVoter" />
      </list>
    </property>
    <property name="allowIfAllAbstainDecisions" value="true" />
  </bean>

  <!-- anonymous bean instead ? -->
  <bean
    class="org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter"
    id="preInvocationAuthorizationAdviceVoter">
    <constructor-arg>
      <ref bean="preInvocationAdvice" />
    </constructor-arg>
  </bean>


  <!-- anonymous bean instead ? -->
  <bean
    class="org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice"
    id="preInvocationAdvice">
    <property name="expressionHandler" ref="expressionHandler" />
  </bean>

  <bean id="expressionHandler"
    class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler">
    <property name="permissionEvaluator" ref="squashtest.core.security.PermissionEvaluator" />
    <property name="parameterNameDiscoverer">
      <!-- We use 2 param name discovery strategies : the standard one and a "arg0, arg1" fallback -->
      <bean
        class="org.squashtest.tm.service.internal.spring.CompositeDelegatingParameterNameDiscoverer">
        <constructor-arg>
          <list>
            <bean
              class="org.springframework.core.LocalVariableTableParameterNameDiscoverer" />
            <bean
              class="org.squashtest.tm.service.internal.spring.ArgumentPositionParameterNameDiscoverer" />
          </list>
        </constructor-arg>
      </bean>
    </property>
  </bean>

  <bean id="squash.security.authenticationProvider.internal" class="org.springframework.security.authentication.dao.DaoAuthenticationProvider">
    <property name="userDetailsService" ref="squashtest.core.security.JdbcUserDetailsManager" />

    <property name="passwordEncoder">
      <bean class="org.springframework.security.authentication.encoding.ShaPasswordEncoder" />
    </property>
  </bean>

<!--  vient de core.web -->
  <bean id="squashtest.core.security.JdbcUserDetailsManager" class="org.squashtest.tm.service.internal.security.SquashUserDetailsManagerImpl">
    <property name="authenticationManager">
      <bean class="org.squashtest.tm.service.security.AuthenticationManagerDelegator">
        <constructor-arg name="authProviderBean" value="squash.security.authenticationProvider.internal" />
      </bean>
    </property> 

    <property name="dataSource" ref="squashtest.core.persistence.jdbc.DataSource" />

    <property name="usersByUsernameQuery" value="select LOGIN, PASSWORD, ACTIVE from AUTH_USER where LOGIN = ?" />

    <property name="groupAuthoritiesByUsernameQuery">
      <value>
        select g.ID, g.QUALIFIED_NAME, ga.AUTHORITY 
				from CORE_GROUP g 
					inner join CORE_GROUP_AUTHORITY ga on ga.GROUP_ID = g.ID
					inner join CORE_GROUP_MEMBER gm on gm.GROUP_ID = g.ID
					inner join CORE_PARTY party on party.PARTY_ID = gm.PARTY_ID							
					left join CORE_TEAM team on team.PARTY_ID = party.PARTY_ID
					left join CORE_TEAM_MEMBER tmemb on tmemb.TEAM_ID = team.PARTY_ID,
					CORE_USER u 
				where( (u.PARTY_ID = tmemb.USER_ID AND u.ACTIVE = true) or (u.PARTY_ID = party.PARTY_ID) ) and ( u.LOGIN = ?)

      </value>
    </property> 
    
   
    <property name="authoritiesByUsernameQuery">
    	<value>
			select cpa.PARTY_ID,  cpa.AUTHORITY from CORE_PARTY_AUTHORITY cpa
			inner join CORE_PARTY party on party.PARTY_ID = cpa.PARTY_ID
			left join CORE_TEAM team on team.PARTY_ID = party.PARTY_ID
			left join CORE_TEAM_MEMBER tmemb on tmemb.TEAM_ID = team.PARTY_ID,
			CORE_USER u 
			where( (u.PARTY_ID = tmemb.USER_ID AND u.ACTIVE = true) or (u.PARTY_ID = party.PARTY_ID) ) and ( u.LOGIN = ?)
		</value>
    </property>

    <property name="changePasswordSql">
      <value>
        update AUTH_USER
        set PASSWORD = ?
        where LOGIN = ?
      </value>
    </property>

    <property name="updateUserSql">
      <value>
        update AUTH_USER
        set PASSWORD = ?, ACTIVE = ?
        where LOGIN = ?
      </value>
    </property>

    <property name="deleteUserSql">
      <value>
        delete from AUTH_USER
        where LOGIN = ?
      </value>
    </property>


    <property name="createUserSql">
      <value>
        insert into AUTH_USER (LOGIN, PASSWORD, ACTIVE) values (?,?,?)
      </value>
    </property>
    
    <property name="createAuthoritySql">
    	<value>
    		insert into CORE_PARTY_AUTHORITY (PARTY_ID, AUTHORITY)
    		values ((select cu.PARTY_ID from CORE_USER cu where cu.LOGIN = ?), ?)
    	</value>
    </property>
    
    
    <property name="deleteUserAuthoritiesSql">
    	<value>
    		delete from CORE_PARTY_AUTHORITY
    		where PARTY_ID in (
    			select cu.PARTY_ID from CORE_USER cu
    			where cu.LOGIN = ?
    		)
    	</value>
    </property>

    
    <property name="userExistsSql" value="select LOGIN from AUTH_USER where LOGIN = ?" />
    
    <!--  
      A successful login attempt requires the user to have at least one authority set (and also a valid login/pass).
      
      Our policy regarding authorities is group-based : there are no per-user authorities and they 
      must be attached to a group.
      
      However due to the restriction mentioned above (about successful login),  we want the user to be granted 
      a default authority if he doesn't belong to a group yet. That authority can merely allow him to 
      connect to the application, but without proper entry in acls he couldn't do much anyway.
      
      So we fetch both personal authorities for the default one, and the group authorities for the real ones. 
      
    -->   
    <!-- 
      Why did the property "enableAuthorities" changed from "true" to "false" ?
    
      The property "enableAuthorities" was at "true" because, at the beginning of squash, users were created "by hand" and for a non admin,  
      no entry was put in the table "CORE_GROUP_MEMBER". In this case, if the property were at "false", the user could not access to  
      the squash workspace.  
      
      Now that users are created with squash, an entry in the table CORE_GROUP_MEMBER is guaranteed. The property could have remained at "true" 
      if it was not for the functionality that allows a user to change his login [Issue 806]. To do that, spring would make us delete the old AUTH_USER entry and create a 
      new one. While deleting a user it would try to delete all his authorities, and that we don't want. Therefore, now enableAuthorities is "false". 
      
    -->
    <!-- 
    	Feat 2699 :
    	
    	parties now have personal authorities.
     -->
    <property name="enableAuthorities" value="true" />
    <property name="enableGroups" value="true" />
  </bean>
  
    <!-- ====== SECURITY PLUMBING ====== -->
  <bean class="org.springframework.security.acls.AclPermissionEvaluator" id="squashtest.core.security.PermissionEvaluator">
    <constructor-arg ref="squashtest.core.security.AclService" />
    <property name="objectIdentityRetrievalStrategy" ref="squashtest.core.security.ObjectIdentityRetrievalStrategy" />
    <property name="objectIdentityGenerator" ref="squashtest.core.security.ObjectIdentityGeneratorStrategy" />
    <property name="permissionFactory" ref="permissionFactory" />
  </bean>

  <bean class="org.squashtest.tm.service.security.acls.jdbc.JdbcManageableAclService" id="squashtest.core.security.AclService" lazy-init="false">
    <constructor-arg ref="squashtest.core.persistence.jdbc.DataSource" />
    <constructor-arg ref="lookupStrategy" />
    <property name="aclCache" ref="aclCache" /> <!-- about that heresy, see comments in JdbcManageableAclService sources -->

    <property name="findChildrenQuery">
      <value>
        select null as obj_id,
        null as class
        from ACL_OBJECT_IDENTITY
        where 0 = 1
      </value>
    </property>
  </bean>


  <bean id="aclCache" class="org.springframework.security.acls.domain.EhCacheBasedAclCache" >
    <constructor-arg>
      <bean class="org.springframework.cache.ehcache.EhCacheFactoryBean">
        <property name="cacheManager">
          <bean class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" />
        </property>
        <property name="overflowToDisk" value="false" />
        <property name="timeToIdle" value="600" />
        <property name="timeToLive" value="1800" />
      </bean>
    </constructor-arg>
  </bean>
  
</beans>
